using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;

namespace org.parser.marpa
{
    public class genericLoggerShr
    {
        public enum genericLoggerLevel_t : @C2CSHARP_TYPE_ENUM@
        {
            GENERICLOGGER_LOGLEVEL_TRACE = 0,
            GENERICLOGGER_LOGLEVEL_DEBUG,
            GENERICLOGGER_LOGLEVEL_INFO,
            GENERICLOGGER_LOGLEVEL_NOTICE,
            GENERICLOGGER_LOGLEVEL_WARNING,
            GENERICLOGGER_LOGLEVEL_ERROR,
            GENERICLOGGER_LOGLEVEL_CRITICAL,
            GENERICLOGGER_LOGLEVEL_ALERT,
            GENERICLOGGER_LOGLEVEL_EMERGENCY
        }
    
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void genericLoggerCallback_t(IntPtr userDatavp, genericLoggerLevel_t logLeveli, IntPtr msgs);
    
        [DllImport("genericLogger.dll", CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.LPStr)]
        // It return a static string, no need to free it in unmanaged code
        public static extern string genericLogger_versions();
    
        [DllImport("genericLogger.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern genericLoggerCallback_t genericLogger_defaultLogCallbackp();
    
        [DllImport("genericLogger.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr genericLogger_userDatavp_setp(IntPtr genericLoggerp, IntPtr userDatavp);
    
        [DllImport("genericLogger.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr genericLogger_userDatavp_getp(IntPtr genericLoggerp);
    
        [DllImport("genericLogger.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern genericLoggerLevel_t genericLogger_logLevel_seti(IntPtr genericLoggerp, genericLoggerLevel_t logLeveli);
    
        [DllImport("genericLogger.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern genericLoggerLevel_t genericLogger_logLevel_geti(IntPtr genericLoggerp);
    
        [DllImport("genericLogger.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr genericLogger_newp(genericLoggerCallback_t logCallbackp, IntPtr userDatavp, genericLoggerLevel_t genericLoggerLeveli);
    
        [DllImport("genericLogger.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr genericLogger_clonep(IntPtr genericLoggerp);
    
        [DllImport("genericLogger.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern void genericLogger_freev(ref IntPtr genericLoggerpp);
    
        // __arglist voluntarilly skipped to a single member
        [DllImport("genericLogger.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern void genericLogger_logv(IntPtr genericLoggerp, genericLoggerLevel_t genericLoggerLeveli, [MarshalAs(UnmanagedType.LPStr)] string fmts, [MarshalAs(UnmanagedType.LPStr)] string msgs);
    
        // Voluntarily skipped
        // [DllImport("genericLogger.dll")]
        // void genericLogger_logapv(genericLogger_t* genericLoggerp, genericLoggerLevel_t genericLoggerLeveli, const char* fmts, va_list ap);
    }

    public class genericLogger : IDisposable
    {
        private static void logCallback(IntPtr userDatavp, genericLoggerShr.genericLoggerLevel_t logLeveli, IntPtr msgs)
        {
            if (userDatavp == IntPtr.Zero || msgs == IntPtr.Zero)
            {
                return;
            }

            GCHandle loggerHandlePtr = GCHandle.FromIntPtr(userDatavp);
            ILogger logger = (ILogger) loggerHandlePtr.Target;
            if (logger == null)
            {
                return;
            }

            string message = Marshal.PtrToStringAnsi(msgs);
            switch (logLeveli)
            {
                case genericLoggerShr.genericLoggerLevel_t.GENERICLOGGER_LOGLEVEL_TRACE:
                    logger.LogTrace(message);
                    break;
                case genericLoggerShr.genericLoggerLevel_t.GENERICLOGGER_LOGLEVEL_DEBUG:
                    logger.LogDebug(message);
                    break;
                case genericLoggerShr.genericLoggerLevel_t.GENERICLOGGER_LOGLEVEL_INFO:
                    logger.LogInformation(message);
                    break;
                case genericLoggerShr.genericLoggerLevel_t.GENERICLOGGER_LOGLEVEL_NOTICE:
                    logger.LogInformation(message);
                    break;
                case genericLoggerShr.genericLoggerLevel_t.GENERICLOGGER_LOGLEVEL_WARNING:
                    logger.LogWarning(message);
                    break;
                case genericLoggerShr.genericLoggerLevel_t.GENERICLOGGER_LOGLEVEL_ALERT:
                    logger.LogWarning(message);
                    break;
                case genericLoggerShr.genericLoggerLevel_t.GENERICLOGGER_LOGLEVEL_EMERGENCY:
                    logger.LogWarning(message);
                    break;
                case genericLoggerShr.genericLoggerLevel_t.GENERICLOGGER_LOGLEVEL_ERROR:
                    logger.LogError(message);
                    break;
                case genericLoggerShr.genericLoggerLevel_t.GENERICLOGGER_LOGLEVEL_CRITICAL:
                    logger.LogCritical(message);
                    break;
            }
        }

        private static readonly object Lock = new object();
        private static readonly Dictionary<IntPtr,genericLogger> Multitons =new Dictionary<IntPtr, genericLogger>();
        public IntPtr genericLoggerp;
        private GCHandle loggerHandle;
        private IntPtr loggerHandlePtr;
        private bool disposedValue;
        private readonly ILogger logger;
    
        private genericLogger(ILogger logger = null)
        {
            this.logger = logger; // null is ok
            // Callback context is a handle to the logger
            if (this.logger != null)
            {
                this.loggerHandle = GCHandle.Alloc(logger, GCHandleType.Normal);
                this.loggerHandlePtr = GCHandle.ToIntPtr(this.loggerHandle);
            }

            this.genericLoggerp = genericLoggerShr.genericLogger_newp(logCallback, this.loggerHandlePtr, genericLoggerShr.genericLoggerLevel_t.GENERICLOGGER_LOGLEVEL_TRACE);
            if (this.genericLoggerp == IntPtr.Zero)
            {
                throw new Exception("genericLogger_newp failure");
            }
        }

        public static genericLogger GetGenericLoggerInstance(ILogger logger = null)
        {
            lock (Lock)
            {
                // Multiton key is genericLoggerp (always != IntPtr.Zero), value is the instance, test is on logger instance.
                genericLogger genericLogger;
                KeyValuePair<IntPtr, genericLogger> keyPair = Multitons.FirstOrDefault(m => m.Value.logger == logger); // Ok if m.Value.logger or logger are null
                if (keyPair.Key != IntPtr.Zero)
                {
                    genericLogger = keyPair.Value;
                }
                else
                {
                    genericLogger = new genericLogger(logger);
                    Multitons.Add(genericLogger.genericLoggerp, genericLogger);
                }

                return genericLogger;
            }
        }

        protected virtual void Dispose(bool disposing)
        {
            if (!disposedValue)
            {
                if (disposing)
                {
                    // DONE: dispose managed state (managed objects)
                }
    
                // DONE: free unmanaged resources (unmanaged objects) and override finalizer
                genericLoggerShr.genericLogger_freev(ref this.genericLoggerp);
                if (this.loggerHandle != null)
                {
                    this.loggerHandle.Free();
                }
                // DONE: set large fields to null
                this.genericLoggerp = IntPtr.Zero;
                disposedValue = true;
            }
        }
    
        // DONE: override finalizer only if 'Dispose(bool disposing)' has code to free unmanaged resources
        ~genericLogger()
        {
            // Do not change this code. Put cleanup code in 'Dispose(bool disposing)' method
            Dispose(disposing: false);
        }
    
        public void Dispose()
        {
            // Do not change this code. Put cleanup code in 'Dispose(bool disposing)' method
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }
    }
}
